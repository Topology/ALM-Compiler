% Final Program For Transition Diagram
% Automatically Generated By ALM Translator 0.1.0.


sorts

#points = {new_york, paris, rome}.

#timeStep = {0, 1}.

#agents = {bob, john}.

#move = {go(john, new_york, paris), go(bob, paris, new_york), go(john, new_york, rome), go(bob, rome, paris), go(bob, rome, new_york), go(bob, new_york, rome), go(john, rome, paris), go(bob, paris, rome), go(john, rome, new_york), go(john, paris, rome), go(bob, new_york, paris), go(john, paris, new_york), go(john, rome), go(bob, rome), go(john, paris), go(bob, paris), go(john, new_york), go(bob, new_york)}.

#actions = {go(john, new_york, paris), go(bob, paris, new_york), go(john, new_york, rome), go(bob, rome, paris), go(bob, rome, new_york), go(bob, new_york, rome), go(john, rome, paris), go(bob, paris, rome), go(john, rome, new_york), go(john, paris, rome), go(bob, new_york, paris), go(john, paris, new_york), go(john, rome), go(bob, rome), go(john, paris), go(bob, paris), go(john, new_york), go(bob, new_york)}.

#things = {bob, john}.

#universe = {new_york, paris, rome, bob, john, go(john, new_york, paris), go(bob, paris, new_york), go(john, new_york, rome), go(bob, rome, paris), go(bob, rome, new_york), go(bob, new_york, rome), go(john, rome, paris), go(bob, paris, rome), go(john, rome, new_york), go(john, paris, rome), go(bob, new_york, paris), go(john, paris, new_york), go(john, rome), go(bob, rome), go(john, paris), go(bob, paris), go(john, new_york), go(bob, new_york)}.

#sort_hierarchy_nodes_ = {universe, timeStep, actions, booleans, integers, points, things, agents, move}.



predicates

% static function
transitive_connectivity().

% static function
has_parent(#sort_hierarchy_nodes_).

% fluent function
loc_in(#things, #points, #timeStep).

% fluent function
connected(#points, #points, #timeStep).

% static function
link(#sort_hierarchy_nodes_, #sort_hierarchy_nodes_).

% static function
has_child(#sort_hierarchy_nodes_).

% attribute function [origin] for sort [move]
move_origin(#move, #points).

% static function
is_a(#universe, #sort_hierarchy_nodes_).

% static function
sink(#sort_hierarchy_nodes_).

% attribute function [actor] for sort [move]
move_actor(#move, #agents).

% special function
occurs(#actions, #timeStep).

% static function
symmetric_connectivity().

% attribute function [dest] for sort [move]
move_dest(#move, #points).

% static function
source(#sort_hierarchy_nodes_).

% static function
instance(#universe, #sort_hierarchy_nodes_).

% static function
subsort(#sort_hierarchy_nodes_, #sort_hierarchy_nodes_).



rules

%---------------------
%-- Section: link
%---------------------

% [points] is a child sort of [universe]
link(points, universe).

% [actions] is a child sort of [universe]
link(actions, universe).

% [move] is a child sort of [actions]
link(move, actions).

% [things] is a child sort of [universe]
link(things, universe).

% [agents] is a child sort of [things]
link(agents, things).

%---------------------
%-- Section: is_a
%---------------------

% Sort Instance [bob] for sort [agents].
is_a(bob, agents).

% Sort Instance [john] for sort [agents].
is_a(john, agents).

% Sort Instance [new_york] for sort [points].
is_a(new_york, points).

% Sort Instance [paris] for sort [points].
is_a(paris, points).

% Sort Instance [rome] for sort [points].
is_a(rome, points).

% Sort Instance [go(X, P1, P2)] for sort [move].
is_a(go(X, P1, P2), move) :- P1!=P2.

% Sort Instance [go(X, P)] for sort [move].
is_a(go(X, P), move).

%---------------------
%-- Section: instance
%---------------------

% Base case of [instance] relation.
% If X is a Y then X is an instance of Y.
instance(X, Y) :- is_a(X, Y).

% Closure On [instance] relation.
% X is an instance of Z if X is an instance of Y and there is a link from Y to Z.
instance(X, Z) :- instance(X, Y), link(Y, Z).

%---------------------
%-- Section: subsort
%---------------------

% Base case of [subsort] relation.
% If there is a link from X to Y in the sort hierarchy then X is a subsort of Y.
subsort(X, Y) :- link(X, Y).

% Closure On [subsort] relation.
% X is a subsort of Z if there is a link from X to Y and Y is a subsort of Z.
subsort(X, Z) :- link(X, Y), subsort(Y, Z).

% [subsort] needs the closed world assumption since it is a total boolean function.
-subsort(X, Y) :- not subsort(X, Y).

%---------------------
%-- Section: has_parent
%---------------------

% Sort X has a parent in the hierarchy if there is a link from X to some sort Y.
has_parent(X) :- link(X, Y).

% [has_parent] needs the closed world assumption since it is a total boolean function.
-has_parent(X) :- not has_parent(X).

%---------------------
%-- Section: has_child
%---------------------

% X has a child in the hierarchy if there is a link from some sort Y to X.
has_child(X) :- link(Y, X).

% [has_child] needs the closed world assumption since it is a total boolean function.
-has_child(X) :- not has_child(X).

%---------------------
%-- Section: source
%---------------------

% If sort X has no child sort, X is a source sort
source(X) :- -has_child(X).

% [source] needs the closed world assumption since it is a total boolean function.
-source(X) :- not source(X).

%---------------------
%-- Section: sink
%---------------------

% If sort X has no parent sort, X is a sink sort
sink(X) :- -has_parent(X).

% [sink] needs the closed world assumption since it is a total boolean function.
-sink(X) :- not sink(X).

%---------------------
%-- Section: Axioms - State Constraints With Only Static Functions
%---------------------

% There are no rules in this section.

%---------------------
%-- Section: Axioms - Satic Function Definitions
%---------------------

% There are no rules in this section.

%---------------------
%-- Section: Structure - Sort Instances
%---------------------

% Sort Instance [bob] for sort [agents].
is_a(bob, agents).

% Sort Instance [john] for sort [agents].
is_a(john, agents).

% Sort Instance [new_york] for sort [points].
is_a(new_york, points).

% Sort Instance [paris] for sort [points].
is_a(paris, points).

% Sort Instance [rome] for sort [points].
is_a(rome, points).

% Sort Instance [go(X, P1, P2)] for sort [move].
is_a(go(X, P1, P2), move) :- P1!=P2.

% Sort Instance [go(X, P)] for sort [move].
is_a(go(X, P), move).

%---------------------
%-- Section: Structure - Attribute Definitions
%---------------------

% Definition of attribute [actor] for instance [go(X, P1, P2)] of sort [move].
move_actor(go(X, P1, P2), A_) :- P1!=P2, A_=X.

% Definition of attribute [origin] for instance [go(X, P1, P2)] of sort [move].
move_origin(go(X, P1, P2), O_) :- P1!=P2, O_=P1.

% Definition of attribute [dest] for instance [go(X, P1, P2)] of sort [move].
move_dest(go(X, P1, P2), D_) :- P1!=P2, D_=P2.

% Definition of attribute [actor] for instance [go(X, P)] of sort [move].
move_actor(go(X, P), A_) :- A_=X.

% Definition of attribute [dest] for instance [go(X, P)] of sort [move].
move_dest(go(X, P), D_) :- D_=P.

%---------------------
%-- Section: Structure - Static Function Definitions
%---------------------

symmetric_connectivity.

-transitive_connectivity.

%---------------------
%-- Section: Axioms - Dynamic Causal Laws
%---------------------

% TS is the Time Step Variable.
loc_in(A, D, TS+1) :- move_actor(X, AO), AO=A, move_dest(X, DO), DO=D, occurs(X, TS), instance(X, move).

%---------------------
%-- Section: Axioms - Executability Conditions
%---------------------

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, move), move_actor(X, AO), AO=A, loc_in(A, LO, TS), move_origin(X, OO), LO!=OO.

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, move), move_actor(X, AO), AO=A, loc_in(A, LO, TS), move_dest(X, DO), LO=DO.

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, move), move_actor(X, AO), AO=A, loc_in(A, LO, TS), LO=O, move_dest(X, DO), DO=D, connected(O, D, TS).

%---------------------
%-- Section: Axioms - State Constraints Containing Fluent Functions
%---------------------

% State Constraint for function [connected].
% TS is the Time Step Variable.
connected(X, X, TS).

% State Constraint for function [connected].
% TS is the Time Step Variable.
connected(X, Y, TS) :- connected(Y, X, TS), symmetric_connectivity.

% State Constraint for function [connected].
% TS is the Time Step Variable.
connected(X, Y, TS) :- connected(Y, X, TS), symmetric_connectivity.

% State Constraint for function [connected].
% TS is the Time Step Variable.
connected(X, Z, TS) :- connected(X, Y, TS), connected(Y, Z, TS), transitive_connectivity.

%---------------------
%-- Section: Axioms - Fluent Function Definitions
%---------------------

% There are no rules in this section.

%---------------------
%-- Section: Optimization - All Facts Computed By Premodel Program.
%---------------------

-transitive_connectivity.

has_parent(points).

has_parent(actions).

has_parent(move).

has_parent(things).

has_parent(agents).

-has_parent(timeStep).

-has_parent(universe).

-has_parent(booleans).

-has_parent(integers).

move_actor(go(bob, rome, new_york), bob).

move_actor(go(bob, new_york, rome), bob).

move_actor(go(bob, paris, rome), bob).

move_actor(go(bob, paris, new_york), bob).

move_actor(go(bob, rome, paris), bob).

move_actor(go(bob, new_york, paris), bob).

move_actor(go(john, rome, paris), john).

move_actor(go(john, rome, new_york), john).

move_actor(go(john, new_york, paris), john).

move_actor(go(john, paris, rome), john).

move_actor(go(john, new_york, rome), john).

move_actor(go(john, paris, new_york), john).

move_actor(go(bob, paris), bob).

move_actor(go(bob, new_york), bob).

move_actor(go(bob, rome), bob).

move_actor(go(john, new_york), john).

move_actor(go(john, rome), john).

move_actor(go(john, paris), john).

move_dest(go(bob, new_york, rome), rome).

move_dest(go(bob, paris, rome), rome).

move_dest(go(john, paris, rome), rome).

move_dest(go(john, new_york, rome), rome).

move_dest(go(john, rome, paris), paris).

move_dest(go(john, new_york, paris), paris).

move_dest(go(bob, rome, paris), paris).

move_dest(go(bob, new_york, paris), paris).

move_dest(go(bob, rome, new_york), new_york).

move_dest(go(john, rome, new_york), new_york).

move_dest(go(bob, paris, new_york), new_york).

move_dest(go(john, paris, new_york), new_york).

move_dest(go(john, rome), rome).

move_dest(go(bob, rome), rome).

move_dest(go(bob, paris), paris).

move_dest(go(john, paris), paris).

move_dest(go(john, new_york), new_york).

move_dest(go(bob, new_york), new_york).

link(points, universe).

link(actions, universe).

link(move, actions).

link(things, universe).

link(agents, things).

has_child(universe).

has_child(actions).

has_child(things).

-has_child(move).

-has_child(timeStep).

-has_child(booleans).

-has_child(integers).

-has_child(points).

-has_child(agents).

sink(timeStep).

sink(universe).

sink(booleans).

sink(integers).

-sink(move).

-sink(things).

-sink(actions).

-sink(points).

-sink(agents).

is_a(bob, agents).

is_a(john, agents).

is_a(new_york, points).

is_a(paris, points).

is_a(rome, points).

is_a(go(john, new_york, paris), move).

is_a(go(bob, paris, new_york), move).

is_a(go(john, new_york, rome), move).

is_a(go(bob, rome, paris), move).

is_a(go(bob, rome, new_york), move).

is_a(go(bob, new_york, rome), move).

is_a(go(john, rome, paris), move).

is_a(go(bob, paris, rome), move).

is_a(go(john, rome, new_york), move).

is_a(go(john, paris, rome), move).

is_a(go(bob, new_york, paris), move).

is_a(go(john, paris, new_york), move).

is_a(go(john, rome), move).

is_a(go(bob, rome), move).

is_a(go(john, paris), move).

is_a(go(bob, paris), move).

is_a(go(john, new_york), move).

is_a(go(bob, new_york), move).

symmetric_connectivity.

source(move).

source(timeStep).

source(booleans).

source(integers).

source(points).

source(agents).

-source(universe).

-source(things).

-source(actions).

move_origin(go(bob, rome, new_york), rome).

move_origin(go(john, rome, paris), rome).

move_origin(go(john, rome, new_york), rome).

move_origin(go(bob, rome, paris), rome).

move_origin(go(bob, paris, rome), paris).

move_origin(go(john, paris, rome), paris).

move_origin(go(bob, paris, new_york), paris).

move_origin(go(john, paris, new_york), paris).

move_origin(go(bob, new_york, rome), new_york).

move_origin(go(john, new_york, paris), new_york).

move_origin(go(john, new_york, rome), new_york).

move_origin(go(bob, new_york, paris), new_york).

instance(bob, agents).

instance(john, agents).

instance(new_york, points).

instance(paris, points).

instance(rome, points).

instance(go(john, new_york, paris), move).

instance(go(bob, paris, new_york), move).

instance(go(john, new_york, rome), move).

instance(go(bob, rome, paris), move).

instance(go(bob, rome, new_york), move).

instance(go(bob, new_york, rome), move).

instance(go(john, rome, paris), move).

instance(go(bob, paris, rome), move).

instance(go(john, rome, new_york), move).

instance(go(john, paris, rome), move).

instance(go(bob, new_york, paris), move).

instance(go(john, paris, new_york), move).

instance(go(john, rome), move).

instance(go(bob, rome), move).

instance(go(john, paris), move).

instance(go(bob, paris), move).

instance(go(john, new_york), move).

instance(go(bob, new_york), move).

instance(bob, things).

instance(john, things).

instance(new_york, universe).

instance(paris, universe).

instance(rome, universe).

instance(go(john, new_york, paris), actions).

instance(go(bob, paris, new_york), actions).

instance(go(john, new_york, rome), actions).

instance(go(bob, rome, paris), actions).

instance(go(bob, rome, new_york), actions).

instance(go(bob, new_york, rome), actions).

instance(go(john, rome, paris), actions).

instance(go(bob, paris, rome), actions).

instance(go(john, rome, new_york), actions).

instance(go(john, paris, rome), actions).

instance(go(bob, new_york, paris), actions).

instance(go(john, paris, new_york), actions).

instance(go(john, rome), actions).

instance(go(bob, rome), actions).

instance(go(john, paris), actions).

instance(go(bob, paris), actions).

instance(go(john, new_york), actions).

instance(go(bob, new_york), actions).

instance(bob, universe).

instance(john, universe).

instance(go(john, new_york, paris), universe).

instance(go(bob, paris, new_york), universe).

instance(go(john, new_york, rome), universe).

instance(go(bob, rome, paris), universe).

instance(go(bob, rome, new_york), universe).

instance(go(bob, new_york, rome), universe).

instance(go(john, rome, paris), universe).

instance(go(bob, paris, rome), universe).

instance(go(john, rome, new_york), universe).

instance(go(john, paris, rome), universe).

instance(go(bob, new_york, paris), universe).

instance(go(john, paris, new_york), universe).

instance(go(john, rome), universe).

instance(go(bob, rome), universe).

instance(go(john, paris), universe).

instance(go(bob, paris), universe).

instance(go(john, new_york), universe).

instance(go(bob, new_york), universe).

subsort(points, universe).

subsort(actions, universe).

subsort(move, actions).

subsort(things, universe).

subsort(agents, things).

subsort(move, universe).

subsort(agents, universe).

-subsort(move, move).

-subsort(move, timeStep).

-subsort(move, things).

-subsort(move, booleans).

-subsort(move, integers).

-subsort(move, points).

-subsort(move, agents).

-subsort(timeStep, move).

-subsort(timeStep, timeStep).

-subsort(timeStep, universe).

-subsort(timeStep, things).

-subsort(timeStep, booleans).

-subsort(timeStep, actions).

-subsort(timeStep, integers).

-subsort(timeStep, points).

-subsort(timeStep, agents).

-subsort(universe, move).

-subsort(universe, timeStep).

-subsort(universe, universe).

-subsort(universe, things).

-subsort(universe, booleans).

-subsort(universe, actions).

-subsort(universe, integers).

-subsort(universe, points).

-subsort(universe, agents).

-subsort(things, move).

-subsort(things, timeStep).

-subsort(things, things).

-subsort(things, booleans).

-subsort(things, actions).

-subsort(things, integers).

-subsort(things, points).

-subsort(things, agents).

-subsort(booleans, move).

-subsort(booleans, timeStep).

-subsort(booleans, universe).

-subsort(booleans, things).

-subsort(booleans, booleans).

-subsort(booleans, actions).

-subsort(booleans, integers).

-subsort(booleans, points).

-subsort(booleans, agents).

-subsort(actions, move).

-subsort(actions, timeStep).

-subsort(actions, things).

-subsort(actions, booleans).

-subsort(actions, actions).

-subsort(actions, integers).

-subsort(actions, points).

-subsort(actions, agents).

-subsort(integers, move).

-subsort(integers, timeStep).

-subsort(integers, universe).

-subsort(integers, things).

-subsort(integers, booleans).

-subsort(integers, actions).

-subsort(integers, integers).

-subsort(integers, points).

-subsort(integers, agents).

-subsort(points, move).

-subsort(points, timeStep).

-subsort(points, things).

-subsort(points, booleans).

-subsort(points, actions).

-subsort(points, integers).

-subsort(points, points).

-subsort(points, agents).

-subsort(agents, move).

-subsort(agents, timeStep).

-subsort(agents, booleans).

-subsort(agents, actions).

-subsort(agents, integers).

-subsort(agents, points).

-subsort(agents, agents).

% END OF PROGRAM
