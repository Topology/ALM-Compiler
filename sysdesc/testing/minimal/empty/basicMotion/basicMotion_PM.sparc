% Pre Model Program
% Automatically Generated By ALM Translator 0.1.0.


sorts

% Source Sort
#points = {new_york, paris, rome}.

#timeStep = {0, 1}.

% Source Sort
#agents = {bob, john}.

% Source Sort
#move = go(#agents, #points, #points) + go(#agents, #points).

#actions = #move.

#things = #agents.

#universe = #points + #actions + #things.

#sort_hierarchy_nodes_ = {universe, timeStep, actions, booleans, integers, points, things, agents, move}.



predicates

% static function
transitive_connectivity().

% static function
has_parent(#sort_hierarchy_nodes_).

% fluent function
loc_in(#things, #points, #timeStep).

% fluent function
connected(#points, #points, #timeStep).

% static function
link(#sort_hierarchy_nodes_, #sort_hierarchy_nodes_).

% static function
has_child(#sort_hierarchy_nodes_).

% attribute function [origin] for sort [move]
move_origin(#move, #points).

% static function
is_a(#universe, #sort_hierarchy_nodes_).

% static function
sink(#sort_hierarchy_nodes_).

% attribute function [actor] for sort [move]
move_actor(#move, #agents).

% special function
occurs(#actions, #timeStep).

% static function
symmetric_connectivity().

% attribute function [dest] for sort [move]
move_dest(#move, #points).

% static function
source(#sort_hierarchy_nodes_).

% static function
instance(#universe, #sort_hierarchy_nodes_).

% static function
subsort(#sort_hierarchy_nodes_, #sort_hierarchy_nodes_).



rules

%---------------------
%-- Section: link
%---------------------

% [points] is a child sort of [universe]
link(points, universe).

% [actions] is a child sort of [universe]
link(actions, universe).

% [move] is a child sort of [actions]
link(move, actions).

% [things] is a child sort of [universe]
link(things, universe).

% [agents] is a child sort of [things]
link(agents, things).

%---------------------
%-- Section: is_a
%---------------------

% Sort Instance [bob] for sort [agents].
is_a(bob, agents).

% Sort Instance [john] for sort [agents].
is_a(john, agents).

% Sort Instance [new_york] for sort [points].
is_a(new_york, points).

% Sort Instance [paris] for sort [points].
is_a(paris, points).

% Sort Instance [rome] for sort [points].
is_a(rome, points).

% Sort Instance [go(X, P1, P2)] for sort [move].
is_a(go(X, P1, P2), move) :- P1!=P2.

% Sort Instance [go(X, P)] for sort [move].
is_a(go(X, P), move).

%---------------------
%-- Section: instance
%---------------------

% Base case of [instance] relation.
% If X is a Y then X is an instance of Y.
instance(X, Y) :- is_a(X, Y).

% Closure On [instance] relation.
% X is an instance of Z if X is an instance of Y and there is a link from Y to Z.
instance(X, Z) :- instance(X, Y), link(Y, Z).

%---------------------
%-- Section: subsort
%---------------------

% Base case of [subsort] relation.
% If there is a link from X to Y in the sort hierarchy then X is a subsort of Y.
subsort(X, Y) :- link(X, Y).

% Closure On [subsort] relation.
% X is a subsort of Z if there is a link from X to Y and Y is a subsort of Z.
subsort(X, Z) :- link(X, Y), subsort(Y, Z).

% [subsort] needs the closed world assumption since it is a total boolean function.
-subsort(X, Y) :- not subsort(X, Y).

%---------------------
%-- Section: has_parent
%---------------------

% Sort X has a parent in the hierarchy if there is a link from X to some sort Y.
has_parent(X) :- link(X, Y).

% [has_parent] needs the closed world assumption since it is a total boolean function.
-has_parent(X) :- not has_parent(X).

%---------------------
%-- Section: has_child
%---------------------

% X has a child in the hierarchy if there is a link from some sort Y to X.
has_child(X) :- link(Y, X).

% [has_child] needs the closed world assumption since it is a total boolean function.
-has_child(X) :- not has_child(X).

%---------------------
%-- Section: source
%---------------------

% If sort X has no child sort, X is a source sort
source(X) :- -has_child(X).

% [source] needs the closed world assumption since it is a total boolean function.
-source(X) :- not source(X).

%---------------------
%-- Section: sink
%---------------------

% If sort X has no parent sort, X is a sink sort
sink(X) :- -has_parent(X).

% [sink] needs the closed world assumption since it is a total boolean function.
-sink(X) :- not sink(X).

%---------------------
%-- Section: Axioms - State Constraints With Only Static Functions
%---------------------

% There are no rules in this section.

%---------------------
%-- Section: Axioms - Satic Function Definitions
%---------------------

% There are no rules in this section.

%---------------------
%-- Section: Structure - Sort Instances
%---------------------

% Sort Instance [bob] for sort [agents].
is_a(bob, agents).

% Sort Instance [john] for sort [agents].
is_a(john, agents).

% Sort Instance [new_york] for sort [points].
is_a(new_york, points).

% Sort Instance [paris] for sort [points].
is_a(paris, points).

% Sort Instance [rome] for sort [points].
is_a(rome, points).

% Sort Instance [go(X, P1, P2)] for sort [move].
is_a(go(X, P1, P2), move) :- P1!=P2.

% Sort Instance [go(X, P)] for sort [move].
is_a(go(X, P), move).

%---------------------
%-- Section: Structure - Attribute Definitions
%---------------------

% Definition of attribute [actor] for instance [go(X, P1, P2)] of sort [move].
move_actor(go(X, P1, P2), A_) :- P1!=P2, A_=X.

% Definition of attribute [origin] for instance [go(X, P1, P2)] of sort [move].
move_origin(go(X, P1, P2), O_) :- P1!=P2, O_=P1.

% Definition of attribute [dest] for instance [go(X, P1, P2)] of sort [move].
move_dest(go(X, P1, P2), D_) :- P1!=P2, D_=P2.

% Definition of attribute [actor] for instance [go(X, P)] of sort [move].
move_actor(go(X, P), A_) :- A_=X.

% Definition of attribute [dest] for instance [go(X, P)] of sort [move].
move_dest(go(X, P), D_) :- D_=P.

%---------------------
%-- Section: Structure - Static Function Definitions
%---------------------

symmetric_connectivity.

-transitive_connectivity.

% END OF PROGRAM
