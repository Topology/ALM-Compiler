%---------------------
%-- ASP{f} PROGRAM ---
%---------------------

%---------------------
%-- ASP{f} PROGRAM: Axioms - State Constraints
%---------------------

% State Constraint for function [connected].
connected(X, X).

% State Constraint for function [connected].
connected(X, Y) :- connected(Y, X), symmetric_connectivity.

% State Constraint for function [connected].
-connected(X, Y) :- -connected(Y, X), symmetric_connectivity.

% State Constraint for function [connected].
connected(X, Z) :- connected(X, Y), connected(Y, Z), transitive_connectivity.

% State Constraint for function [loc_in].
loc_in(C)=P :- holding(T, C), loc_in(T)=P.

% State Constraint for function [loc_in].
loc_in(T)=P :- holding(T, C), loc_in(C)=P.

% State Constraint for function [holding].
-holding(X, Y2) :- holding(X, Y1), Y1!=Y2.

% State Constraint for function [dest].
dest(A)=top(E) :- elevation(A)=E.

% State Constraint: This condition is impossible in all states.
:- loc_in(E)=top(E).

% State Constraint for function [connected].
connected(top(box), P) :- loc_in(box)=P, instance(P, floor_points).

% State Constraint for function [connected].
-connected(top(box), P) :- loc_in(box)!=P, instance(P, floor_points).

% State Constraint for function [connected].
connected(P1, P2) :- instance(P1, floor_points), instance(P2, floor_points).

% State Constraint for function [connected].
-connected(P1, P2) :- instance(P1, ceiling_points), instance(P2, points), P1!=P2.

%---------------------
%-- ASP{f} PROGRAM: Axioms - Dynamic Causal Laws
%---------------------

loc_in(A)=D :- actor(X)=A, dest(X)=D, occurs(X), instance(X, move).

holding(X, Y) :- grasper(A)=X, grasped_thing(A)=Y, occurs(A), instance(A, grasp).

-holding(X, Y) :- releaser(A)=X, released_thing(A)=Y, occurs(A), instance(A, release).

%---------------------
%-- ASP{f} PROGRAM: Axioms - Function Definitions
%---------------------

% Definition for function [is_held].
is_held(X) :- holding(T, X).

% Definition for function [can_reach].
can_reach(M, O) :- loc_in(M)=loc_in(O).

% Definition for function [can_reach].
can_reach(monkey, banana) :- loc_in(box)=P, under(P, banana), loc_in(monkey)=top(box).

%---------------------
%-- ASP{f} PROGRAM: Structure - Sort Instances
%---------------------

% Sort Instance [top(box)] for sort [movable_points].
is_a(top(box), movable_points).

% Sort Instance [under_banana] for sort [floor_points].
is_a(under_banana, floor_points).

% Sort Instance [initial_monkey] for sort [floor_points].
is_a(initial_monkey, floor_points).

% Sort Instance [initial_box] for sort [floor_points].
is_a(initial_box, floor_points).

% Sort Instance [initial_banana] for sort [ceiling_points].
is_a(initial_banana, ceiling_points).

% Sort Instance [move(P)] for sort [move].
instance(move(P), move) :- instance(P, points), instance(monkey, agents).

% Sort Instance [carry(box, P)] for sort [carry].
is_a(carry(box, P), carry) :- instance(P, floor_points), instance(monkey, agents), instance(box, carriables).

% Sort Instance [grasp(C)] for sort [grasp].
is_a(grasp(C), grasp) :- instance(C, carriables), instance(monkey, agents).

% Sort Instance [release(C)] for sort [release].
is_a(release(C), release) :- instance(C, carriables), instance(monkey, agents).

% Sort Instance [climb(box)] for sort [climb].
is_a(climb(box), climb) :- instance(monkey, agents), instance(box, elevations).

%---------------------
%-- ASP{f} PROGRAM: Axioms - Fluent Function Definitions
%---------------------

% Definition for dom_f being positive when defined fluent function [is_held] has a known definition.
dom_is_held(X0) :- is_held(X0)=Y.

% Definition for dom_f being positive when defined fluent function [can_reach] has a known definition.
dom_can_reach(X0) :- can_reach(X0)=Y.

%---------------------
%-- ASP{f} PROGRAM: Structure - Static Function Definitions
%---------------------

under(under_banana, banana).

symmetric_connectivity.

-transitive_connectivity.

%---------------------
%-- ASP{f} PROGRAM: Structure - Attribute Definitions
%---------------------

% Definition of attribute [actor] for instance [move(P)] of sort [move].
actor(move(P))=A_ :- instance(P, points), instance(monkey, agents), A_=monkey.

% Definition of attribute [dest] for instance [move(P)] of sort [move].
dest(move(P))=D_ :- instance(P, points), instance(monkey, agents), D_=P.

% Definition of attribute [actor] for instance [carry(box, P)] of sort [carry].
actor(carry(box, P))=A_ :- instance(P, floor_points), instance(monkey, agents), A_=monkey.

% Definition of attribute [carried_object] for instance [carry(box, P)] of sort [carry].
carried_object(carry(box, P))=C_ :- instance(P, floor_points), instance(monkey, agents), instance(box, carriables), C_=box.

% Definition of attribute [dest] for instance [carry(box, P)] of sort [carry].
dest(carry(box, P))=D_ :- instance(P, floor_points), instance(monkey, agents), instance(box, carriables), D_=P.

% Definition of attribute [grasper] for instance [grasp(C)] of sort [grasp].
grasper(grasp(C))=G_ :- instance(C, carriables), instance(monkey, agents), G_=monkey.

% Definition of attribute [grasped_thing] for instance [grasp(C)] of sort [grasp].
grasped_thing(grasp(C))=G_1 :- instance(C, carriables), instance(monkey, agents), G_1=C.

% Definition of attribute [releaser] for instance [release(C)] of sort [release].
releaser(release(C))=R_ :- instance(C, carriables), instance(monkey, agents), R_=monkey.

% Definition of attribute [released_thing] for instance [release(C)] of sort [release].
released_thing(release(C))=R_1 :- instance(C, carriables), instance(monkey, agents), R_1=C.

% Definition of attribute [actor] for instance [climb(box)] of sort [climb].
actor(climb(box))=A_ :- instance(monkey, agents), A_=monkey.

% Definition of attribute [elevation] for instance [climb(box)] of sort [climb].
elevation(climb(box))=E_ :- instance(monkey, agents), instance(box, elevations), E_=box.

%---------------------
%-- ASP{f} PROGRAM: Axioms - Satic Function Definitions
%---------------------

% Definition for dom_f being positive when attribute function [actor] of sort [move] has a known definition.
dom_move_actor(X0) :- move_actor(X0)=Y.

% Definition for dom_f being positive when attribute function [origin] of sort [move] has a known definition.
dom_move_origin(X0) :- move_origin(X0)=Y.

% Definition for dom_f being positive when attribute function [dest] of sort [move] has a known definition.
dom_move_dest(X0) :- move_dest(X0)=Y.

% Definition for dom_f being positive when static function [symmetric_connectivity] has a known definition.
dom_symmetric_connectivity :- symmetric_connectivity=Y.

% Definition for dom_f being positive when static function [transitive_connectivity] has a known definition.
dom_transitive_connectivity :- transitive_connectivity=Y.

% Definition for dom_f being positive when attribute function [carried_object] of sort [carry] has a known definition.
dom_carry_carried_object(X0) :- carry_carried_object(X0)=Y.

% Definition for dom_f being positive when attribute function [grasper] of sort [grasp] has a known definition.
dom_grasp_grasper(X0) :- grasp_grasper(X0)=Y.

% Definition for dom_f being positive when attribute function [grasped_thing] of sort [grasp] has a known definition.
dom_grasp_grasped_thing(X0) :- grasp_grasped_thing(X0)=Y.

% Definition for dom_f being positive when attribute function [releaser] of sort [release] has a known definition.
dom_release_releaser(X0) :- release_releaser(X0)=Y.

% Definition for dom_f being positive when attribute function [released_thing] of sort [release] has a known definition.
dom_release_released_thing(X0) :- release_released_thing(X0)=Y.

% Definition for dom_f being positive when attribute function [elevation] of sort [climb] has a known definition.
dom_climb_elevation(X0) :- climb_elevation(X0)=Y.

% Definition for dom_f being positive when static function [under] has a known definition.
dom_under(X0) :- under(X0)=Y.

%---------------------
%-- ASP{f} PROGRAM: Axioms - Executability Conditions
%---------------------

% Executability Condition for when [X] is impossible to execute.
:- occurs(X), instance(X, move), actor(X)=A, loc_in(A)!=origin(X).

% Executability Condition for when [X] is impossible to execute.
:- occurs(X), instance(X, move), actor(X)=A, loc_in(A)=dest(X).

% Executability Condition for when [X] is impossible to execute.
:- occurs(X), instance(X, move), actor(X)=A, loc_in(A)=O, dest(X)=D, -connected(O, D).

% Executability Condition for when [A] is impossible to execute.
:- occurs(A), instance(A, grasp), grasper(A)=X, grasped_thing(A)=Y, holding(X, Y).

% Executability Condition for when [A] is impossible to execute.
:- occurs(A), instance(A, grasp), grasper(A)=X, grasped_thing(A)=Y, -can_reach(X, Y).

% Executability Condition for when [A] is impossible to execute.
:- occurs(A), instance(A, release), releaser(A)=X, released_thing(A)=Y, -holding(X, Y).

% Executability Condition for when [X] is impossible to execute.
:- occurs(X), instance(X, move), actor(X)=A, is_held(A).

% Executability Condition for when [X] is impossible to execute.
:- occurs(X), instance(X, carry), actor(X)=A, carried_object(X)=C, -holding(A, C).

% Executability Condition for when [X] is impossible to execute.
:- occurs(X), instance(X, climb), actor(X)=A, elevation(X)=O, loc_in(O)!=loc_in(A).

%---------------------
%-- ASP{f} PROGRAM: Axioms - State Constraints Containing Fluent Functions
%---------------------

% State Constraint for dom_f being positive when basic fluent function [connected] has a known definition.
dom_connected(X0) :- connected(X0)=Y.

% State Constraint for dom_f being positive when basic fluent function [loc_in] has a known definition.
dom_loc_in(X0) :- loc_in(X0)=Y.

% State Constraint for dom_f being positive when basic fluent function [holding] has a known definition.
dom_holding(X0) :- holding(X0)=Y.

%-------------------------
%-- END ASP{f} PROGRAM ---
%-------------------------



