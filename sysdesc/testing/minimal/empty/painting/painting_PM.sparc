% Pre Model Program
% Automatically Generated By ALM Translator 0.1.0.


sorts

% Source Sort
#carriables = {}.

#timeStep = {0, 1}.

% Source Sort
#elevations = {}.

% Source Sort
#agents = {}.

#things = #carriables + #elevations + #agents.

% Source Sort
#ceiling_points = {initial_banana}.

% Source Sort
#floor_points = {under_banana, initial_monkey, initial_box}.

% Source Sort
#movable_points = {top(box)}.

#points = #ceiling_points + #floor_points + #movable_points.

% Source Sort
#carry = carry(box, #points).

% Source Sort
#climb = {climb(box)}.

#move = #carry + #climb.

% Source Sort
#grasp = grasp(#things).

% Source Sort
#release = release(#things).

#actions = #move + #grasp + #release.

#universe = #things + #actions + #points.

#sort_hierarchy_nodes_ = {universe, timeStep, actions, booleans, integers, points, things, agents, move, carriables, carry, grasp, release, elevations, climb, floor_points, ceiling_points, movable_points}.



predicates

% static function
has_parent(#sort_hierarchy_nodes_).

% static function
transitive_connectivity().

% fluent function
loc_in(#things, #points, #timeStep).

% attribute function [carried_object] for sort [carry]
carry_carried_object(#carry, #carriables).

% fluent function
holding(#agents, #things, #timeStep).

% static function
link(#sort_hierarchy_nodes_, #sort_hierarchy_nodes_).

% fluent function
connected(#points, #points, #timeStep).

% static function
has_child(#sort_hierarchy_nodes_).

% attribute function [actor] for sort [move]
move_actor(#move, #agents).

% attribute function [grasped_thing] for sort [grasp]
grasp_grasped_thing(#grasp, #things).

% special function
occurs(#actions, #timeStep).

% static function
symmetric_connectivity().

% static function
instance(#universe, #sort_hierarchy_nodes_).

% static function
subsort(#sort_hierarchy_nodes_, #sort_hierarchy_nodes_).

% attribute function [releaser] for sort [release]
release_releaser(#release, #agents).

% attribute function [released_thing] for sort [release]
release_released_thing(#release, #things).

% attribute function [elevation] for sort [climb]
climb_elevation(#climb, #elevations).

% fluent function
is_held(#things, #timeStep).

% static function
under(#floor_points, #things).

% attribute function [origin] for sort [move]
move_origin(#move, #points).

% static function
sink(#sort_hierarchy_nodes_).

% static function
is_a(#universe, #sort_hierarchy_nodes_).

% attribute function [grasper] for sort [grasp]
grasp_grasper(#grasp, #agents).

% attribute function [dest] for sort [move]
move_dest(#move, #points).

% static function
source(#sort_hierarchy_nodes_).

% fluent function
can_reach(#agents, #things, #timeStep).



rules

%---------------------
%-- Section: link
%---------------------

% [things] is a child sort of [universe]
link(things, universe).

% [carriables] is a child sort of [things]
link(carriables, things).

% [elevations] is a child sort of [things]
link(elevations, things).

% [agents] is a child sort of [things]
link(agents, things).

% [actions] is a child sort of [universe]
link(actions, universe).

% [move] is a child sort of [actions]
link(move, actions).

% [carry] is a child sort of [move]
link(carry, move).

% [climb] is a child sort of [move]
link(climb, move).

% [grasp] is a child sort of [actions]
link(grasp, actions).

% [release] is a child sort of [actions]
link(release, actions).

% [points] is a child sort of [universe]
link(points, universe).

% [ceiling_points] is a child sort of [points]
link(ceiling_points, points).

% [floor_points] is a child sort of [points]
link(floor_points, points).

% [movable_points] is a child sort of [points]
link(movable_points, points).

%---------------------
%-- Section: is_a
%---------------------

% Sort Instance [top(box)] for sort [movable_points].
is_a(top(box), movable_points).

% Sort Instance [under_banana] for sort [floor_points].
is_a(under_banana, floor_points).

% Sort Instance [initial_monkey] for sort [floor_points].
is_a(initial_monkey, floor_points).

% Sort Instance [initial_box] for sort [floor_points].
is_a(initial_box, floor_points).

% Sort Instance [initial_banana] for sort [ceiling_points].
is_a(initial_banana, ceiling_points).

% Sort Instance [move(P)] for sort [move].
is_a(move(P), move) :- instance(P, points).

% Sort Instance [carry(box, P)] for sort [carry].
is_a(carry(box, P), carry) :- instance(P, floor_points).

% Sort Instance [grasp(C)] for sort [grasp].
is_a(grasp(C), grasp) :- instance(C, carriables).

% Sort Instance [release(C)] for sort [release].
is_a(release(C), release) :- instance(C, carriables).

% Sort Instance [climb(box)] for sort [climb].
is_a(climb(box), climb).

%---------------------
%-- Section: instance
%---------------------

% Base case of [instance] relation.
% If X is a Y then X is an instance of Y.
instance(X, Y) :- is_a(X, Y).

% Closure On [instance] relation.
% X is an instance of Z if X is an instance of Y and there is a link from Y to Z.
instance(X, Z) :- instance(X, Y), link(Y, Z).

%---------------------
%-- Section: subsort
%---------------------

% Base case of [subsort] relation.
% If there is a link from X to Y in the sort hierarchy then X is a subsort of Y.
subsort(X, Y) :- link(X, Y).

% Closure On [subsort] relation.
% X is a subsort of Z if there is a link from X to Y and Y is a subsort of Z.
subsort(X, Z) :- link(X, Y), subsort(Y, Z).

% [subsort] needs the closed world assumption since it is a total boolean function.
-subsort(X, Y) :- not subsort(X, Y).

%---------------------
%-- Section: has_parent
%---------------------

% Sort X has a parent in the hierarchy if there is a link from X to some sort Y.
has_parent(X) :- link(X, Y).

% [has_parent] needs the closed world assumption since it is a total boolean function.
-has_parent(X) :- not has_parent(X).

%---------------------
%-- Section: has_child
%---------------------

% X has a child in the hierarchy if there is a link from some sort Y to X.
has_child(X) :- link(Y, X).

% [has_child] needs the closed world assumption since it is a total boolean function.
-has_child(X) :- not has_child(X).

%---------------------
%-- Section: source
%---------------------

% If sort X has no child sort, X is a source sort
source(X) :- -has_child(X).

% [source] needs the closed world assumption since it is a total boolean function.
-source(X) :- not source(X).

%---------------------
%-- Section: sink
%---------------------

% If sort X has no parent sort, X is a sink sort
sink(X) :- -has_parent(X).

% [sink] needs the closed world assumption since it is a total boolean function.
-sink(X) :- not sink(X).

%---------------------
%-- Section: Axioms - State Constraints With Only Static Functions
%---------------------

% State Constraint for function [dest].
move_dest(A, top(E)) :- climb_elevation(A, EO), EO=E.

%---------------------
%-- Section: Axioms - Satic Function Definitions
%---------------------

% There are no rules in this section.

%---------------------
%-- Section: Structure - Sort Instances
%---------------------

% Sort Instance [top(box)] for sort [movable_points].
is_a(top(box), movable_points).

% Sort Instance [under_banana] for sort [floor_points].
is_a(under_banana, floor_points).

% Sort Instance [initial_monkey] for sort [floor_points].
is_a(initial_monkey, floor_points).

% Sort Instance [initial_box] for sort [floor_points].
is_a(initial_box, floor_points).

% Sort Instance [initial_banana] for sort [ceiling_points].
is_a(initial_banana, ceiling_points).

% Sort Instance [move(P)] for sort [move].
is_a(move(P), move) :- instance(P, points).

% Sort Instance [carry(box, P)] for sort [carry].
is_a(carry(box, P), carry) :- instance(P, floor_points).

% Sort Instance [grasp(C)] for sort [grasp].
is_a(grasp(C), grasp) :- instance(C, carriables).

% Sort Instance [release(C)] for sort [release].
is_a(release(C), release) :- instance(C, carriables).

% Sort Instance [climb(box)] for sort [climb].
is_a(climb(box), climb).

%---------------------
%-- Section: Structure - Attribute Definitions
%---------------------

% Definition of attribute [actor] for instance [move(P)] of sort [move].
move_actor(move(P), A_) :- instance(P, points), A_=monkey.

% Definition of attribute [dest] for instance [move(P)] of sort [move].
move_dest(move(P), D_) :- instance(P, points), D_=P.

% Definition of attribute [actor] for instance [carry(box, P)] of sort [carry].
move_actor(carry(box, P), A_) :- instance(P, floor_points), A_=monkey.

% Definition of attribute [carried_object] for instance [carry(box, P)] of sort [carry].
carry_carried_object(carry(box, P), C_) :- instance(P, floor_points), C_=box.

% Definition of attribute [dest] for instance [carry(box, P)] of sort [carry].
move_dest(carry(box, P), D_) :- instance(P, floor_points), D_=P.

% Definition of attribute [grasper] for instance [grasp(C)] of sort [grasp].
grasp_grasper(grasp(C), G_) :- instance(C, carriables), G_=monkey.

% Definition of attribute [grasped_thing] for instance [grasp(C)] of sort [grasp].
grasp_grasped_thing(grasp(C), G_1) :- instance(C, carriables), G_1=C.

% Definition of attribute [releaser] for instance [release(C)] of sort [release].
release_releaser(release(C), R_) :- instance(C, carriables), R_=monkey.

% Definition of attribute [released_thing] for instance [release(C)] of sort [release].
release_released_thing(release(C), R_1) :- instance(C, carriables), R_1=C.

% Definition of attribute [actor] for instance [climb(box)] of sort [climb].
move_actor(climb(box), A_) :- A_=monkey.

% Definition of attribute [elevation] for instance [climb(box)] of sort [climb].
climb_elevation(climb(box), E_) :- E_=box.

%---------------------
%-- Section: Structure - Static Function Definitions
%---------------------

under(under_banana, banana).

symmetric_connectivity.

-transitive_connectivity.

% END OF PROGRAM
