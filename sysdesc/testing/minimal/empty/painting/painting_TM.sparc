% Final Program For Transition Diagram
% Automatically Generated By ALM Translator 0.1.0.


sorts

#agents = {jenny}.

#timeStep = {0, 1}.

#objects = {wall_1}.

#colors = {yellow, white}.

#paint = {painting(jenny, wall_1, white), painting(jenny, wall_1, yellow), painting(jenny, white), painting(jenny, yellow)}.

#actions = {painting(jenny, wall_1, white), painting(jenny, wall_1, yellow), painting(jenny, white), painting(jenny, yellow)}.

#things = {yellow, white, jenny}.

#universe = {wall_1, yellow, white, jenny, painting(jenny, wall_1, white), painting(jenny, wall_1, yellow), painting(jenny, white), painting(jenny, yellow)}.

#sort_hierarchy_nodes_ = {universe, timeStep, actions, booleans, integers, objects, things, agents, colors, paint}.



predicates

% static function
darkerColors(#colors).

% fluent function
appropriateColor(#objects, #colors, #timeStep).

% fluent function
painted(#agents, #objects, #colors, #timeStep).

% static function
has_parent(#sort_hierarchy_nodes_).

% static function
link(#sort_hierarchy_nodes_, #sort_hierarchy_nodes_).

% static function
has_child(#sort_hierarchy_nodes_).

% static function
is_a(#universe, #sort_hierarchy_nodes_).

% static function
sink(#sort_hierarchy_nodes_).

% attribute function [actor] for sort [paint]
paint_actor(#paint, #agents).

% fluent function
has(#agents, #colors, #timeStep).

% special function
occurs(#actions, #timeStep).

% static function
source(#sort_hierarchy_nodes_).

% fluent function
hasColor(#objects, #colors, #timeStep).

% attribute function [color] for sort [paint]
paint_color(#paint, #colors).

% static function
instance(#universe, #sort_hierarchy_nodes_).

% static function
lighterColors(#colors).

% static function
subsort(#sort_hierarchy_nodes_, #sort_hierarchy_nodes_).

% attribute function [wall] for sort [paint]
paint_wall(#paint, #objects).



rules

%---------------------
%-- Section: link
%---------------------

% [actions] is a child sort of [universe]
link(actions, universe).

% [paint] is a child sort of [actions]
link(paint, actions).

% [objects] is a child sort of [universe]
link(objects, universe).

% [things] is a child sort of [universe]
link(things, universe).

% [agents] is a child sort of [things]
link(agents, things).

% [colors] is a child sort of [things]
link(colors, things).

%---------------------
%-- Section: is_a
%---------------------

% Sort Instance [yellow] for sort [colors].
is_a(yellow, colors).

% Sort Instance [white] for sort [colors].
is_a(white, colors).

% Sort Instance [wall_1] for sort [objects].
is_a(wall_1, objects).

% Sort Instance [jenny] for sort [agents].
is_a(jenny, agents).

% Sort Instance [painting(A, W, C)] for sort [paint].
is_a(painting(A, W, C), paint).

% Sort Instance [painting(A, C)] for sort [paint].
is_a(painting(A, C), paint).

%---------------------
%-- Section: instance
%---------------------

% Base case of [instance] relation.
% If X is a Y then X is an instance of Y.
instance(X, Y) :- is_a(X, Y).

% Closure On [instance] relation.
% X is an instance of Z if X is an instance of Y and there is a link from Y to Z.
instance(X, Z) :- instance(X, Y), link(Y, Z).

%---------------------
%-- Section: subsort
%---------------------

% Base case of [subsort] relation.
% If there is a link from X to Y in the sort hierarchy then X is a subsort of Y.
subsort(X, Y) :- link(X, Y).

% Closure On [subsort] relation.
% X is a subsort of Z if there is a link from X to Y and Y is a subsort of Z.
subsort(X, Z) :- link(X, Y), subsort(Y, Z).

% [subsort] needs the closed world assumption since it is a total boolean function.
-subsort(X, Y) :- not subsort(X, Y).

%---------------------
%-- Section: has_parent
%---------------------

% Sort X has a parent in the hierarchy if there is a link from X to some sort Y.
has_parent(X) :- link(X, Y).

% [has_parent] needs the closed world assumption since it is a total boolean function.
-has_parent(X) :- not has_parent(X).

%---------------------
%-- Section: has_child
%---------------------

% X has a child in the hierarchy if there is a link from some sort Y to X.
has_child(X) :- link(Y, X).

% [has_child] needs the closed world assumption since it is a total boolean function.
-has_child(X) :- not has_child(X).

%---------------------
%-- Section: source
%---------------------

% If sort X has no child sort, X is a source sort
source(X) :- -has_child(X).

% [source] needs the closed world assumption since it is a total boolean function.
-source(X) :- not source(X).

%---------------------
%-- Section: sink
%---------------------

% If sort X has no parent sort, X is a sink sort
sink(X) :- -has_parent(X).

% [sink] needs the closed world assumption since it is a total boolean function.
-sink(X) :- not sink(X).

%---------------------
%-- Section: Axioms - State Constraints With Only Static Functions
%---------------------

% There are no rules in this section.

%---------------------
%-- Section: Axioms - Satic Function Definitions
%---------------------

% There are no rules in this section.

%---------------------
%-- Section: Structure - Sort Instances
%---------------------

% Sort Instance [yellow] for sort [colors].
is_a(yellow, colors).

% Sort Instance [white] for sort [colors].
is_a(white, colors).

% Sort Instance [wall_1] for sort [objects].
is_a(wall_1, objects).

% Sort Instance [jenny] for sort [agents].
is_a(jenny, agents).

% Sort Instance [painting(A, W, C)] for sort [paint].
is_a(painting(A, W, C), paint).

% Sort Instance [painting(A, C)] for sort [paint].
is_a(painting(A, C), paint).

%---------------------
%-- Section: Structure - Attribute Definitions
%---------------------

% Definition of attribute [actor] for instance [painting(A, W, C)] of sort [paint].
paint_actor(painting(A, W, C), A_) :- A_=A.

% Definition of attribute [wall] for instance [painting(A, W, C)] of sort [paint].
paint_wall(painting(A, W, C), W_) :- W_=W.

% Definition of attribute [color] for instance [painting(A, W, C)] of sort [paint].
paint_color(painting(A, W, C), C_) :- C_=C.

% Definition of attribute [actor] for instance [painting(A, C)] of sort [paint].
paint_actor(painting(A, C), A_) :- A_=A.

% Definition of attribute [color] for instance [painting(A, C)] of sort [paint].
paint_color(painting(A, C), C_) :- C_=C.

%---------------------
%-- Section: Structure - Static Function Definitions
%---------------------

darkerColors(white).

lighterColors(yellow).

%---------------------
%-- Section: Axioms - Dynamic Causal Laws
%---------------------

% TS is the Time Step Variable.
painted(A, O, C, TS+1) :- paint_actor(X, AO), AO=A, paint_wall(X, WO), WO=O, paint_color(X, CO), CO=C, appropriateColor(O, C, TS), occurs(X, TS), instance(X, paint).

%---------------------
%-- Section: Axioms - Executability Conditions
%---------------------

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, paint), paint_actor(X, AO), AO=A, paint_color(X, CO), CO=C, has(A, C, TS).

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, paint), occurs(Y, TS), instance(Y, paint), paint_actor(X, AO), AO=A, paint_actor(Y, AO1), AO1=B, A!=B, paint_wall(X, WO), WO=W, paint_wall(Y, WO1), WO1=W.

%---------------------
%-- Section: Axioms - State Constraints Containing Fluent Functions
%---------------------

% State Constraint for function [painted].
% TS is the Time Step Variable.
-painted(A, O, C1, TS+1) :- painted(A, O, PO, TS), PO=C2, C1!=C2.

%---------------------
%-- Section: Axioms - Fluent Function Definitions
%---------------------

% Definition for function [hasColor].
% TS is the Time Step Variable.
hasColor(O, C, TS) :- painted(A, O, PO, TS), PO=C.

% Definition for function [appropriateColor].
% TS is the Time Step Variable.
appropriateColor(O, C1, TS) :- hasColor(O, C2, TS), lighterColors(C2), darkerColors(C1), C1!=C2.

%---------------------
%-- Section: Optimization - All Facts Computed By Premodel Program.
%---------------------

paint_actor(painting(jenny, wall_1, white), jenny).

paint_actor(painting(jenny, wall_1, yellow), jenny).

paint_actor(painting(jenny, white), jenny).

paint_actor(painting(jenny, yellow), jenny).

darkerColors(white).

source(timeStep).

source(objects).

source(booleans).

source(paint).

source(colors).

source(integers).

source(agents).

-source(universe).

-source(things).

-source(actions).

has_parent(actions).

has_parent(paint).

has_parent(objects).

has_parent(things).

has_parent(agents).

has_parent(colors).

-has_parent(timeStep).

-has_parent(universe).

-has_parent(booleans).

-has_parent(integers).

paint_wall(painting(jenny, wall_1, white), wall_1).

paint_wall(painting(jenny, wall_1, yellow), wall_1).

link(actions, universe).

link(paint, actions).

link(objects, universe).

link(things, universe).

link(agents, things).

link(colors, things).

has_child(universe).

has_child(actions).

has_child(things).

-has_child(timeStep).

-has_child(objects).

-has_child(booleans).

-has_child(paint).

-has_child(colors).

-has_child(integers).

-has_child(agents).

is_a(yellow, colors).

is_a(white, colors).

is_a(wall_1, objects).

is_a(jenny, agents).

is_a(painting(jenny, wall_1, white), paint).

is_a(painting(jenny, wall_1, yellow), paint).

is_a(painting(jenny, white), paint).

is_a(painting(jenny, yellow), paint).

paint_color(painting(jenny, wall_1, white), white).

paint_color(painting(jenny, wall_1, yellow), yellow).

paint_color(painting(jenny, white), white).

paint_color(painting(jenny, yellow), yellow).

sink(timeStep).

sink(universe).

sink(booleans).

sink(integers).

-sink(objects).

-sink(things).

-sink(paint).

-sink(actions).

-sink(colors).

-sink(agents).

instance(yellow, colors).

instance(white, colors).

instance(wall_1, objects).

instance(jenny, agents).

instance(painting(jenny, wall_1, white), paint).

instance(painting(jenny, wall_1, yellow), paint).

instance(painting(jenny, white), paint).

instance(painting(jenny, yellow), paint).

instance(yellow, things).

instance(white, things).

instance(wall_1, universe).

instance(jenny, things).

instance(painting(jenny, wall_1, white), actions).

instance(painting(jenny, wall_1, yellow), actions).

instance(painting(jenny, white), actions).

instance(painting(jenny, yellow), actions).

instance(yellow, universe).

instance(white, universe).

instance(jenny, universe).

instance(painting(jenny, wall_1, white), universe).

instance(painting(jenny, wall_1, yellow), universe).

instance(painting(jenny, white), universe).

instance(painting(jenny, yellow), universe).

lighterColors(yellow).

subsort(actions, universe).

subsort(paint, actions).

subsort(objects, universe).

subsort(things, universe).

subsort(agents, things).

subsort(colors, things).

subsort(paint, universe).

subsort(agents, universe).

subsort(colors, universe).

-subsort(timeStep, timeStep).

-subsort(timeStep, universe).

-subsort(timeStep, objects).

-subsort(timeStep, things).

-subsort(timeStep, booleans).

-subsort(timeStep, paint).

-subsort(timeStep, actions).

-subsort(timeStep, colors).

-subsort(timeStep, integers).

-subsort(timeStep, agents).

-subsort(universe, timeStep).

-subsort(universe, universe).

-subsort(universe, objects).

-subsort(universe, things).

-subsort(universe, booleans).

-subsort(universe, paint).

-subsort(universe, actions).

-subsort(universe, colors).

-subsort(universe, integers).

-subsort(universe, agents).

-subsort(objects, timeStep).

-subsort(objects, objects).

-subsort(objects, things).

-subsort(objects, booleans).

-subsort(objects, paint).

-subsort(objects, actions).

-subsort(objects, colors).

-subsort(objects, integers).

-subsort(objects, agents).

-subsort(things, timeStep).

-subsort(things, objects).

-subsort(things, things).

-subsort(things, booleans).

-subsort(things, paint).

-subsort(things, actions).

-subsort(things, colors).

-subsort(things, integers).

-subsort(things, agents).

-subsort(booleans, timeStep).

-subsort(booleans, universe).

-subsort(booleans, objects).

-subsort(booleans, things).

-subsort(booleans, booleans).

-subsort(booleans, paint).

-subsort(booleans, actions).

-subsort(booleans, colors).

-subsort(booleans, integers).

-subsort(booleans, agents).

-subsort(paint, timeStep).

-subsort(paint, objects).

-subsort(paint, things).

-subsort(paint, booleans).

-subsort(paint, paint).

-subsort(paint, colors).

-subsort(paint, integers).

-subsort(paint, agents).

-subsort(actions, timeStep).

-subsort(actions, objects).

-subsort(actions, things).

-subsort(actions, booleans).

-subsort(actions, paint).

-subsort(actions, actions).

-subsort(actions, colors).

-subsort(actions, integers).

-subsort(actions, agents).

-subsort(colors, timeStep).

-subsort(colors, objects).

-subsort(colors, booleans).

-subsort(colors, paint).

-subsort(colors, actions).

-subsort(colors, colors).

-subsort(colors, integers).

-subsort(colors, agents).

-subsort(integers, timeStep).

-subsort(integers, universe).

-subsort(integers, objects).

-subsort(integers, things).

-subsort(integers, booleans).

-subsort(integers, paint).

-subsort(integers, actions).

-subsort(integers, colors).

-subsort(integers, integers).

-subsort(integers, agents).

-subsort(agents, timeStep).

-subsort(agents, objects).

-subsort(agents, booleans).

-subsort(agents, paint).

-subsort(agents, actions).

-subsort(agents, colors).

-subsort(agents, integers).

-subsort(agents, agents).

% END OF PROGRAM
